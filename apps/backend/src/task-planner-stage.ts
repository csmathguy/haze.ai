export interface PlannerArtifactState {
  createdAt: string;
  goals: string[];
  steps: string[];
  risks: string[];
}

export interface PlannerTestingPlannedState {
  gherkinScenarios: string[];
  unitTestIntent: string[];
  integrationTestIntent: string[];
  notes: string | null;
}

export interface PlannerExecutionInput {
  taskTitle: string;
  taskDescription: string;
  acceptanceCriteria: string[];
  latestHumanAnswer: string | null;
  transitionAt: string;
  existingPlanningArtifact: PlannerArtifactState;
  existingTestingPlanned: PlannerTestingPlannedState;
}

export interface PlannerExecutionOutput {
  planningArtifact: PlannerArtifactState;
  testingPlanned: PlannerTestingPlannedState;
  reasonCodes: string[];
  requiresClarification: boolean;
}

export function runPlannerStage(input: PlannerExecutionInput): PlannerExecutionOutput {
  const reasonCodes: string[] = [];
  const planningArtifact = { ...input.existingPlanningArtifact };
  const testingPlanned = { ...input.existingTestingPlanned };

  if (input.acceptanceCriteria.length === 0) {
    reasonCodes.push("MISSING_ACCEPTANCE_CRITERIA");
    planningArtifact.risks = ensureContains(
      planningArtifact.risks,
      "Acceptance criteria are missing; clarification required before implementation."
    );
  }
  if (input.taskDescription.trim().length === 0) {
    reasonCodes.push("MISSING_DESCRIPTION");
    planningArtifact.risks = ensureContains(
      planningArtifact.risks,
      "Task description is empty; planning assumptions may be wrong."
    );
  }
  if (input.acceptanceCriteria.some((criterion) => /\bor\b/i.test(criterion))) {
    reasonCodes.push("AC_AMBIGUOUS");
    planningArtifact.risks = ensureContains(
      planningArtifact.risks,
      "Acceptance criteria include ambiguous alternatives; clarification is required."
    );
  }

  planningArtifact.goals = ensurePlanningGoals(
    planningArtifact.goals,
    input.taskTitle,
    input.acceptanceCriteria
  );
  planningArtifact.steps = ensurePlanningSteps(
    planningArtifact.steps,
    input.taskTitle,
    input.acceptanceCriteria
  );
  planningArtifact.risks = ensurePlanningRisks(planningArtifact.risks);

  testingPlanned.gherkinScenarios = ensureTestingPlannedGherkin(
    testingPlanned.gherkinScenarios,
    input.taskTitle,
    input.acceptanceCriteria
  );
  testingPlanned.unitTestIntent = ensureContains(
    testingPlanned.unitTestIntent,
    "Add unit tests for planner-stage artifact generation and questionnaire decision logic."
  );
  testingPlanned.integrationTestIntent = ensureContains(
    testingPlanned.integrationTestIntent,
    "Add integration tests for planning->awaiting_human redirect and resume flow."
  );
  if (!testingPlanned.notes) {
    testingPlanned.notes =
      "Generated by planner stage execution; refine after clarification answers if required.";
  }

  if (input.latestHumanAnswer) {
    planningArtifact.steps = ensureContains(
      planningArtifact.steps,
      `Incorporate human clarification: ${input.latestHumanAnswer}`
    );
  }

  const requiresClarification = reasonCodes.length > 0 && !input.latestHumanAnswer;

  return {
    planningArtifact,
    testingPlanned,
    reasonCodes,
    requiresClarification
  };
}

export function readStringArray(value: unknown): string[] {
  if (!Array.isArray(value)) {
    return [];
  }
  const normalized: string[] = [];
  for (const entry of value) {
    if (typeof entry !== "string") {
      continue;
    }
    const trimmed = entry.trim();
    if (trimmed.length === 0) {
      continue;
    }
    normalized.push(trimmed);
  }
  return normalized;
}

function ensurePlanningGoals(
  existing: string[],
  taskTitle: string,
  acceptanceCriteria: string[]
): string[] {
  let next = [...existing];
  next = ensureContains(next, `Define implementation outcomes for: ${taskTitle}`);
  if (acceptanceCriteria.length > 0) {
    next = ensureContains(
      next,
      `Map implementation plan to ${acceptanceCriteria.length} acceptance criteria.`
    );
  } else {
    next = ensureContains(next, "Clarify missing acceptance criteria before implementation.");
  }
  return next;
}

function ensurePlanningSteps(
  existing: string[],
  taskTitle: string,
  acceptanceCriteria: string[]
): string[] {
  let next = [...existing];
  next = ensureContains(next, `Review task scope and dependencies for "${taskTitle}".`);
  next = ensureContains(next, "Draft minimal implementation approach and sequence.");
  next = ensureContains(next, "Define validation strategy before coding.");
  if (acceptanceCriteria.length === 0) {
    next = ensureContains(next, "Collect acceptance criteria clarification from operator.");
  }
  return next;
}

function ensurePlanningRisks(existing: string[]): string[] {
  let next = [...existing];
  next = ensureContains(next, "Execution risk from incomplete planning assumptions.");
  next = ensureContains(next, "Potential rework if clarification responses change scope.");
  return next;
}

function ensureTestingPlannedGherkin(
  existing: string[],
  taskTitle: string,
  acceptanceCriteria: string[]
): string[] {
  let next = [...existing];
  next = ensureContains(
    next,
    `Given task "${taskTitle}" plan is approved, when implementation starts, then planned steps map to acceptance criteria and verification artifacts.`
  );
  if (acceptanceCriteria.length === 0) {
    next = ensureContains(
      next,
      "Given missing acceptance criteria, when planner runs, then task is redirected to awaiting_human with clarification questionnaire."
    );
  }
  return next;
}

function ensureContains(values: string[], value: string): string[] {
  if (values.includes(value)) {
    return values;
  }
  return [...values, value];
}
